Javascript Primitives

Variables:
    let (and var, technically): This is the general way to declare a variable. 
    const: These are for immutable variables, like the hex of a color or the amount of time to load page. 
        names for const: Do all CAPS for variables that were known before like color.
            Use camelCase for those unknown, like normal var.

Javascript Primitives:
Numbers:
    These are normal numbers that basic operations can be performed on. This includes BOTH INTEGERS AND FLOATS.
    There are special Numbers that get their own names. 
        NaN (Not a Number), Infinity, and -Infinity.
        NaN is basically a failed computation. If NaN is present anywhere in a math formula, the result will also be NaN, with the exception being NaN ** 0 = 1

BigInt:
    JS doesn't have the space to store integers larger than (2^53-1) (that’s 9007199254740991), or less than -(2^53-1) for negatives.
    Adding a n to the end of an integer will make it a BigInt. 

Strings:
    Strings are characters between 'quotes', "double quotes", or `backticks`.
    Remember template strings? Use backticks to embed variables in a string. `Hello ${varName}, Welcome back!` is a good example.
    Template literals respect new lines, all the others require \n.
    To embed quotes, you can either do another option or escape:
        'He said, "Hello."' or "He said, \"Hello.\""

Booleans:
    These are basically true or false. 

null:
    This is just a falsey nothing. Nothing or empty. 

undefined:
    Basically means that a value is not assigned. For example if I don't say let name = "Ezra" but call name, it will be undefined. 

Objects and Symbols:
    
Use typeof x to check type.
    To convert types: String(123) to convert num to string and Number('123') to convert to number. 

For String Methods, See introJs.js Second assignment.

=== COMAPRISONS ===

< <= > >= - These are exactly what they are in math. 
= - this is how to assign a variable
== this is how to check if two elements are equal
!= this is "not equals, without ligatures, ! = 

When doing a string comparison:
    As long as each letter in the equivalent position is the same, there's no problem and we move to the next letter. When there's a difference:
        Letters later in the alphabet are "greater".
            Strings of numbers looks at the first letter and compares, so '2' > '12'
        Additional letters make a string greater.

Different type comparisons:
    JS will convert a string of numbers to actual numbers. 
    true == 1, and false == 0

Strict equality:
    == can't actually tell the difference between false and 0.
    === doesn't do a type conversion, it's exact equals.
    !== is "not exactly equals" and is ! = = 

null and undefined:
    null == undefined: true
    null === undefined: false
    for < and > null becomes 0 and undefined NaN

=== if, else if, else, switch ===
    These are pretty self explanatory. Remember the order in which they are written matters. 

=== Logical Operators ===

|| OR
    returns true when any of the given options are true and false when all of the given options are false.
        This can also be used to find the truthy value. It will evaluate left to right and return the first truthy value. If no values are truthy, it will return the final value.  
&& AND 
    basically opposite of OR. returns false unless all given options are true. 
        Finds first falsy value and returns it. If all values are truthy, it returns the final value. 
            && HAS HIGHER PRECEDENCE THAN OR

This article says not to use && to replace if statements. 
Other sources seem to like it. That is, instead of

if (x == 0) alert('number is zero');
(x == 0) && alert('number is zero');

!  NOT
    converts to boolean and then flips. 
!! 
    This returns the truth value.
?? NULLISH Coalescing 

=== Functions ===

function name (args) {
    stuff in here
}

OR ANON

(function () {
    stuff in here
})

OR ARROW

(event) => {
    stuff in here
}

OR SINGLE LINE return (no parens)

event => event.num * 2
    See example in JS doc

=== ERRORS ===

Most common kind of error seems:

Reference error:
    This is, for example, what happens when you attempt to access a variable that hasn't been declared yet. 
Syntax error:
    When you done goofed on the syntax like leaving out parens. 
Type error:
    When you attempt to do something with the wrong type, like trying to push an element to a string rather than an array. (btw, concat will work there).


=== Clean Code ===

Be consistent with names, as in don't just back and forth between calling someone player, player1, and user. 

Variables should be named for nouns, and functions for verbs.

Consider setting some things like constand numbers to variables, and as a bonus show how you got there. instead of 

setTimeout(stopTimer, 3600000)

try

const MILISECONDS_PER_HOUR = 60 * 60 * 1000;
setTimeout(stopTimer, MILISECONDS_PER_HOUR);

=== Arrays ===

mostly a refresher, but remember, Arrays are actually Objects. 

You can make arrays with let newArr = new Array(1, 2, 3);

Useful methods that I don't use much:
concat() is for merging arrays. 
arr1.concat(arr2, arr3, etc);

delete. 
delete arr[0];
This will leave a hole. 0 will remain, but with no value. 

flat()
this will flatten an nested array.

don't forget continue to skip a loop, and break to stop.

=== What is the DOM ===

DOM is the Document Object Model, which is a tree representation of the content of a webpage. 

Selectors are how to target nodes in the DOM.

 In the above example, you could use the following selectors to refer to <div class="display"></div>:

    div.display
    .display
    #container > .display
    div#container > div.display

The most common query selectors are
    element.querySelector(selector) - returns a reference to the first match of selector.
    element.querySelectorAll(selectors) - returns a “nodelist” containing references to all of the matches of the selectors.

document.createElement(tagName, [options]) lets you create elements but doesn't insert the new element into the DOM. 

Append elements

    parentNode.appendChild(childNode) - appends childNode as the last child of parentNode.
    parentNode.insertBefore(newNode, referenceNode) - inserts newNode into parentNode before referenceNode.

Remove elements

    parentNode.removeChild(child) - removes child from parentNode on the DOM and returns a reference to child.

you can add elements and then style them in line as follow. 

let div = document.createElement('div');

div.style.color = 'blue';
or
div.style.cssText = 'color: blue; background: white;'
or
div.setAttribute('style', 'color: blue');

You may need to edit kebab case items:

div.style.background-color // doesn't work - attempts to subtract color from div.style.background
div.style.backgroundColor // accesses the div's background-color style
div.style['background-color'] // also works
div.style.cssText = "background-color: white;" // sets the div's background-color by assigning a CSS string

You can also edit attributes:

div.setAttribute('id', 'theDive') - updates 'id' to 'theDiv';
div.getAttribute('id') - returns what the id is, like 'theDiv';
div.removeAttribute('id') - this will remove the id from the element. 

Classes - pretty straightforward

div.classList.add('class');
div.classList.remove('class');
div.classList.toggle('class'); if 'class' removes, if not, adds. 

Add text 
div.textContent = 'your string here';

Add HTML
div.innerHTML = '<span>Hello World!</span>'

=== EVENT LISTENERS ===

You can add these directly to the button html tag:
    <button onclick="alert("Hello, World!)";

Otherwise, select the button element in question, and in JS, write:
    buttonItem.onclick = () => alert("Whatever you want");

For multiple event listeners, try the supreme way:
    buttonItem.addEventListener("click", () => {
        alert("This is an event click!");
    });

e can be passed to event listeners, and it contains a lot of important information. 

e.target will point to the current element that we are working with. 


=== Other Selectors ===

document.getElementById('element id');
    note that you don't use a # as you would with querySelector.

document.getElementsByName('name');
    Returns a list of elements with the specified "name" property.
    Good for selecting all radio buttons, for example.

document.getElementsByTagName('tag');
    This is good for getting a list of h2 elements, or the like.

document.getElementsByClassName('class');
    similar to others.

document.querySelector('css element')
    This is the most useful in that in can select tags, .class, #id, and '*' to select first element.

document.querySelectorAll('css element');
    Same as previous, but returns a list of all relevant. You can also select multiple types, in a comma separated way. 
        document.querySelectorAll('h1, .heading, #title');

node.parentNode
    Gets the parent element of the selected element. 

node.nextElementSibling
    Yeah

node.firstChild, node.lastChild, node.childNodes
node.firstElementChild, node.lastElementChild, node.children
    Adding the word element will return the entire element. 

document.createElement('element');
    This is how you create elements, and how we've been doing it. 

parentNode.appendChild('new element');
    Add the new element to an existing one. 

=== Loading Scripts into JS ===

function loadJSAsync(url) {
    let script = document.createElement('script');
    script.src = url;
    script.async = true;
    document.body.appendChild(script);
}

loadJS('/lib.js');

element.textContent = 'text'
element.innerHTML = 'html content'

Creating elements with document.createElement() is way faster and more secure than parent.innerHTML = '<p>Hi</p>'

=== DOCUMENT FRAGMENT ===

This is all about composing new DOM elements before adding them to an active DOM tree.

Making changes to the document fragment doesn't render to the DOM and doesn't have a performance hit. 

let fragment = new DocumentFragment();
or
let fragment = document.createDocumentFragment();

This is kind of a staging area for creating multiple elements so there's only one new addition to the DOM. 

EXAMPLE
Maybe you have an unordered list in the DOM tree and you want to add numerous different list items. 

You'd map over each item, creating a list item, and append each of these items to the fragment, and then once finished you'd attach the fragment to the DOM. 


element.before('new element') lets you place a new element before a preexisting element on the DOM tree. 
    You can add an array of element with spread, such as adding list items in this example before the ones already there:
        list.firstChild.before(...newItems);

element.after('new element') works exactly the same as before, except, you know, after...

*** Insert Adjacent https://www.javascripttutorial.net/javascript-dom/javascript-insertadjacenthtml/ ***

parentElement.insertAdjacentHTML(positionName, element)
    This is just yet another way of inserting elements. 
    There are four position names
        'beforebegin': before the element
        'afterbegin': before its first child of the element.
        'beforeend': after the last child of the element
        'afterend': after the element

    The element is a full element like <p>element</p>
    like innerHTML, it seems this has security vulnerabilities. 

parentNode.replaceChild(newChild, oldChild);
example
menu.replaceChild(li, menu.firstElementChild);

parentNode.removeChild(childNode);
    this is how we have been removing elements.
    you can use this in a loop to remove all children. 
        if you set this to a variable, it will store the removed element so you can use it laster.

element.clone(deep);
    if you don't set deep, then only the node itself is cloned.
    if you set deep to true, then it will clone child elements.
        let clonedNode = original.clone(true);

element.append()
    What are the differences between append and appendChild

Differences	    append()	            appendChild()
Return value:	undefined	            The appended Node object
Input:	        Multiple Node Objects	A single Node object
Parameters:	    Node and DOMString	    Only Node

parentNode.prepend(...nodes);
    it's like append but will insert before the first child element rather than after the last child element

