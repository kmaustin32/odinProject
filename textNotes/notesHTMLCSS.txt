/* Display types:
  Block: Each box will be on the next available line. 
  In-line: remains in line of the surrounding elements. No height or width. 
  In-line Block: Like previous except height and width of the elements are respected. 

Orientation:
  Margin: This changes the amount of space from the edge of the element to the outside. 
  Padding: Directs the amount of space between the middle items and the edge of the box. 
  border: this is the border, between the inside and outside of the box. 

Model:
  Box: This adds the dimensions of the element to the margin and border, so a 100px element with a 20px border and 80px margin makes the total box 200px
  Alternative Box: Makes the absolute size the declared size, so a 100px element stays 100px.
    box-sizing: border-box */

/* Display: Flex 
  This is used on the container, and then the items within will be arranged accordingly. You can also nest this feature. 

Flex: this takes three arguments, and is shorthand for flex-grow, flex-shrink, and flex-basis.
  Flex: 1; is equal to writing 1, 1, 0.
  Flex-Grow: this property will make the flex item this is applied to a multiple in size. For example, 2 would make it twice as wide as another item with the value of 1.
  Flex-Shrink: this property tells us how small an item can get when all of the items in the container add up to more space than the container itself. 1 causes a shrink evenly, while 0 will prevent shrinking. 
  Flex-Basis requires a more intense detail:
    Flex-basis
    flex-basis simply sets the initial size of a flex item, so any sort of flex-growing or flex-shrinking starts from that baseline size. The shorthand value defaults to flex-basis: 0%. The reason we had to change it to auto in the flex-shrink example is that with the basis set to 0, those items would ignore the item’s width, and everything would shrink evenly. Using auto as a flex-basis tells the item to check for a width declaration (width: 250px).
    
    Important note about flex-basis:
    There is a difference between the default value of flex-basis and the way the flex shorthand defines it if no flex-basis is given. The actual default value for flex-basis is auto, but when you specify flex: 1 on an element, it interprets that as flex: 1 1 0. If you want to only adjust an item’s flex-grow you can simply do so directly, without the shorthand. Or you can be more verbose and use the full 3 value shorthand flex: 1 1 auto, which is also equivalent to using flex: auto.
    
    What is flex: auto?
    If you noticed, we mentioned a new flex shorthand flex: auto in the previous note. However we didn’t fully introduce it. flex: auto is one of the shorthands of flex. When auto is defined as a flex keyword it is equivalent to the values of flex-grow: 1, flex-shrink: 1 and flex-basis: auto or to flex: 1 1 auto using the flex shorthand. Note that flex: auto is not the default value when using the flex shorthand despite the name being “auto” which may be slightly confusing at first. You will encounter and learn more about flex: auto and its potential use-cases when reading through the assignment section. */

/* Flex CONTAINER has a property called gap that is really useful for creating space between elements in the flex container.
Flex-wrap: wrap will wrap the items. The default is nowrap, and it will overflow the container. 

Flexbox starts with ideal size, so columns will not be the same size. 
It's all ratios, so shrink of 1 will not make them all the same sizes.
So, Flex-basis of 0 makes all columns the same width, but auto will deal with ideals. Flex basis is very similar to width, but not exactly the same.  */

/* Flex direction: Column vs Row just kind of switches everything. 

The following is a nice way to flip a flex for a smaller screen.
@media  (min-width: 800px) {
  flex-direction: row;
}

justify-content works only when the container has extra space and it moves items in the container. Center, start, and end all kind of work, and put them where you would expect. There's is also space-between and space-around and more importantly, there is space-evenly.

align-items: the default is stretch. flex-start or end will move them up or down if there are smaller items in the container. 
align-self lets you pick a single item that wants to do it's own thing.  */
/* 
https://www.joshwcomeau.com/css/interactive-guide-to-flexbox/
This is an excellent source for envisioning flexbox.

putting flex-min on the child item will prevent overflow in a shrinking container. 
Remember, an item with text can only shrink to the width of the longest word there. 

Use margin and margin: auto to separate elements with extra space as well. 

flex-wrap: wrap; will make it so items will wrap to the next line. 
align-items works the same, just on each row. 
We also have align-content, which will align the newly created rows themselves.  */


=== INTERMEDIATE HTML AND CSS ===

HTML

<html></html> This is the root element. It's at the top of the document. 

Then there's the metadata
<base>

<head></head></head>
  This is basically what stores the basic metadata
<link>
  For gathering content from other files. Use for CSS and Favicons
<script></script>
  This is obviously for JavaScript
<style></style>
  This is where you might want to but some doc specific HTML
<title></title>
  This is what will show up in the browser tab
<meta> 

<body></body>
  Basically everything that's going to be rendered goes in here

There are various specifically named tags like header footer article and more. This also includes hgroup like h1 and h5 etc. 

There are also various text tags that we have seen before. The most important is obviously div, but we have also seen ol, ul, li and others like menu which is basically a ul with a better name and blockquote. 

=== Emmet ===

We've made a shortcut for wrapping code in a tags, alt + a and a shortcut for removing said tags, alt + s.

Here are some important things about emmet. 
  - if you don't specify the tag and only provide and id or classs, it wall automatically assume you want a div. 
  - you can chain by using greater than like in css. div>nav>ul>li*3 for example.
  - putting text in [] will let you add attributes. div[data-selected].
  - putting {} will let you add text. li*3{I'm a list item}.
  - you can count with $. header>nav>ul>li*3{I am list item $} will count. Also, $$ will zero pad your number. 
  - you can create siblings with +. header+main+footer.
  - you can escape out of children with ^. header>nav^main+footer alternatively, you can use (). (header>nav)main+footer is the same as above.


=== SVG ===

SVGs are Scalable Vector Graphics. They can be resized without losing quality, which makes them ideal for web usage. You can also change their qualities through CSS and JS, which is another major positive. 

Icons, backgrounds, layers are all good use cases for SVGs.

What's the difference between SVG and a normal image? Well an SVG uses math to determine its shape while a normal "raster" image uses a pixel grid to determine how the image looks. This is why is can scale so well. 

SVGs are actually comprised of XML, which is a bit similar to HTML which means their source can be editied. 

xmlns - This is saying what kind of xml we are working with. Some browsers need this to function

viewBox - This is essentially the size of the SVG canvas, and will determined where the inner pieces fall. 

<circle>, <rect>, <path>, and <text> - These are the core building blocks of SVG. You can tell what they are based on the names for the most part. 

fill and stroke are attributes that can be changed via CSS. 

There are two methods of implementing SVGs. Link and inline. The advantage to linking is the code is much more readable and will not slow the page on load. As a drawback, its properties can not be accessed for use with JS. In line looks messy and is slow, but you can edit the attributes. 

=== TABLES ===

these are created with <table></table>
tr are rows, th are the headings, and td are the data

<table>
  <tr>
    <th>Heading One</th>
    <th>Hading Two</th>
  </tr>
  <tr>
    <td>Data one</td>
    <td>Date two</td>
  </tr>
</table>

you can also add colors
<colgroup>
  <col />
  <col style="background-color: yellow />
</colgroup>

See the attributes like colspan and rowspan to change amount of space used on th and td elements.

=== DEFAULT STYLES ===

Reset browser default styles with the following options

Meyer reset is a very common one.
https://meyerweb.com/eric/tools/css/reset/

Normalize.css is another popular option. This one works a bit differently, as it normalizes the defaults amount popular browsers.
https://necolas.github.io/normalize.css/

sanitize.css is also another modern option that's extememly opinionated. 

in previous projects, I've just done:

* {
  margin: 0;
  padding: 0;
}

Which is also fine, and it clears everything away. 

=== COMMON CSS UNITS ===

Absolute Units: The only one you should use in webDev is px, for pixels.
Obviously, cm and in don't really make sense on digital formats.

Relative Units: These are obviously not fixed. They are technically used for font size, but can be applied to various other elements as well. The two to look out for are em and rem. In general, we will prefer to use rem. 

em: 1em is the font size of the element, or the parent element. For example, if the text size of something 16px, then 4em will be 64px (16*4).

rem: this takes the font size of ROOT element, either :root or html. This makes more sense to use because context will not change the size. 

Viewport Units: vh is viewport height and vw is viewport width. 20vh will take up 20% of the viewport, and similar. 

Line Height: Like lh and rlh, much like em and rem. You can use this with a repeating linear gradient in order to make notepad lines. 

Percentages work as you expect. They take the parent element and use a percent of that. This is not based on font-size, though it can be. It's based on the same attribute of the parent element. If you have nested similar elements, then you'll get progressively smaller content. 

Numbers: These shouldn't be in quotes, but they are there. 

*** Start on color next time ***
https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units

First on the list are the color keywords, which I use refrequently. It seems one shouldn't mix and match the way they declare colors in a project. But unless you're only going to use the list of predefined colors, you're kind of going to have to. 

Hex can come with three or six digits and are comprised of digits 0-9 and a-f. When doing the six character layout, there's two digits for each of the rgb channels.

Obviously you can use rgb() or rgba() in order to adjust the opacity. Color sections take numbers 0-255, and opacity is 0-1, with zero transparent and one opaque. 

of course there is srgb()

There are various ways to use hue to specify color. 

HWB or hwb()
  This uses Hue, White and Black. Hue uses the color wheel and thus takes a number 0-360. The other two are 0-100%. 
HSL or hsl()
  This is Hue, Saturation, Brightness.
  same as above for inputs.

If you want to use an image as a background, you'd use url().

There is also a property for background-position, which lets you move the image in the background of the parent container.

There are functions to use as well, like translate() rotate() scale() and calc()

=== FONTS ===

We already went over font family in earlier lessons. 

There are fallback fonts after the desired font. One common list for matching system is:
font-family: system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";

Often you can link to online font libraries, but it's better to post your own. 

see the following:
@font-face {
  font-family: my-cool-font;
  src: url(../fonts/the-font-file.woff);
}

h1 {
  font-family: my-cool-font, sans-serif;
}

Various font styles
font-style: italic; will make things italic for example. Use this instead of em in HTML if you don't actually want to emphasize.

letter-spacing lets you add space between characters
line-height does just about what you'd expect in Word or the like
text-transform can do things like change the case of a string of text
text-shadow does what you think too

ellipses overflow

here is a class that does this. It's not just one things like text-overflow
.overflowing {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

Background, Border, Border-radius, box-shadow, overflow opacity, these are all things I have used in odin projects even up to this point.

=== ADVANCED CSS SELECTORS ===

> child combinator (this one is known)
  Assume the highest level div has the class main. 
  main div { style } will style all children divs.
  main > div will select all children only.
  main > div > div will select all grandchildren.

+ adjacent sibling combinator
  Assume we have three divs on the same level, div1 div2 and div3.
  div1 + div will select div2.
  div1 + div + div will select div3.

~ general sibling combinator
  Assume the above. 
  div1 ~ div will select div2 AND div3.

=== PSEUDO SELECTORS ===

This is comprised of pseudo classes and pseudo elements. 

Pseudo classes
These have been used before. They are a single colon followed with the instruction. 
:hover :focus :active :link :visited and the like. 
  These are applied the CSS classes/selectors and change style when active. 

Structural Pseudo Classes

:root 
  this is kind of like selecting the HTML element. It applies style everywhere. There are a few subtle differences though. 

:first-child and :last-child
  See names

:empty
  Selects element that has no children.

:only-child 
  Selects the element with no siblings.

:nth-child -- this is the best one.
  :nth-child(3) selects the third child element
  :nth-child(5n) selects every fifth child element
  :nth-child(3 + 5n) selects third and every fifth element
  :nth-child(even) selects even child elements



